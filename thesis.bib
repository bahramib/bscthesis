@manual{cppreferencenodiscard,
	title = {{\CC{}} attribute: nodiscard (since C++17)},
	url = {http://en.cppreference.com/w/cpp/language/attributes/nodiscard},
  note = {accessed at: 2022-05-18}
}

@inproceedings{mapreduce,
	title	= {MapReduce: Simplified Data Processing on Large Clusters},
	author	= {Jeffrey Dean and Sanjay Ghemawat},
	year	= {2004},
	booktitle	= {OSDI'04: Sixth Symposium on Operating System Design and Implementation},
	pages	= {137--150},
	address	= {San Francisco, CA}
}

@manual{clangCTU,
  title  = {Cross Translation Unit (CTU) Analysis},
  url = {http://clang.llvm.org/docs/analyzer/user-docs/CrossTranslationUnit.html},
  note = {accessed at: 2022-05-18},
  author = {Horváth, Gábor and Márton, Gábor and Gera, Zoltán and Fülöp, Endre and Krupp, Dániel and Porkoláb, Zoltán}
}

@misc{coverity,
  title = {Coverity Scan - Static Analysis},
  url = {http://scan.coverity.com/o/oss_success_stories/69},
  note = {accessed at: 2022-05-18}
}

@misc{upstream1,
  author       = {Benedek Attila Bahrami},
  title        = {[clang-tidy] Add infrastructure support for running on project-level information},
  url 		   = {http://reviews.llvm.org/D124447},
  howpublished = {Revision on Phabricator for review},
  year         = {2022}
}

@misc{upstream2,
  author       = {Benedek Attila Bahrami},
  title        = {[clang-tidy] Add the misc-discarded-return-value check},
  url 		   = {http://reviews.llvm.org/D124446},
  howpublished = {Revision on Phabricator for review},
  year         = {2022}
}

@misc{upstream3,
  author       = {Benedek Attila Bahrami},
  title        = {[clang-tidy] Add project-level analysis support to misc-discarded-return-value},
  url 		   = {http://reviews.llvm.org/D124448},
  howpublished = {Revision on Phabricator for review},
  year         = {2022}
}

@book{kandr,
author = {Kernighan, Brian W. and Ritchie, Dennis M.},
title = {The C Programming Language},
year = {1988},
isbn = {0131103709},
publisher = {Prentice Hall Professional Technical Reference},
edition = {2nd},
}

@article{statcompare,
author = {Lenarduzzi, Valentina and Pecorelli, Fabiano and Saarimäki, Nyyti and Lujan, Savanna and Palomba, Fabio},
year = {2022},
month = {01},
pages = {},
title = {A Critical Comparison on Six Static Analysis Tools: Detection Agreement and Precision},
journal = {SSRN Electronic Journal},
doi = {10.2139/ssrn.4044439}
}

@manual{matcherref,
  title  = {AST Matcher Reference},
  url = {http://clang.llvm.org/docs/LibASTMatchersReference.html},
  author = {{LLVM Foundation}},
  note = {accessed at: 2022-05-18}
}

@article{googlearticle,
author = {Rice, Andrew and Aftandilian, Edward and Jaspan, Ciera and Johnston, Emily and Pradel, Michael and Arroyo-Paredes, Yulissa},
title = {Detecting Argument Selection Defects},
year = {2017},
issue_date = {October 2017},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {1},
number = {OOPSLA},
url = {http://doi.org/10.1145/3133928},
doi = {10.1145/3133928},
abstract = { Identifier names are often used by developers to convey additional information about the meaning of a program over and above the semantics of the programming language itself. We present an algorithm that uses this information to detect argument selection defects, in which the programmer has chosen the wrong argument to a method call in Java programs. We evaluate our algorithm at Google on 200 million lines of internal code and 10 million lines of predominantly open-source external code and find defects even in large, mature projects such as OpenJDK, ASM, and the MySQL JDBC. The precision and recall of the algorithm vary depending on a sensitivity threshold. Higher thresholds increase precision, giving a true positive rate of 85%, reporting 459 true positives and 78 false positives. Lower thresholds increase recall but lower the true positive rate, reporting 2,060 true positives and 1,207 false positives. We show that this is an order of magnitude improvement on previous approaches. By analyzing the defects found, we are able to quantify best practice advice for API design and show that the probability of an argument selection defect increases markedly when methods have more than five arguments. },
journal = {Proc. ACM Program. Lang.},
month = {oct},
articleno = {104},
numpages = {22},
keywords = {name-based program analysis, static analysis, empirical study, method arguments}
}

@misc{memcached,
  title = {{MemcacheD}},
  note = {\texttt{1.6.8}, \texttt{8335dd84ca85651115d518d7e3d963de9d82e22f}, accessed at: 2022-05-18},
  url = {http://github.com/memcached/memcached.git}
}

@misc{tmux,
  title = {{TMux}},
  note = {\texttt{2.6}, \texttt{bd71cbbe276432ce8869baa0f2d55433e1ab820c}, accessed at: 2022-05-18},
  url = {http://github.com/tmux/tmux.git}
}

@misc{curl,
  title = {{cURL}},
  note = {\texttt{curl-7\_66\_0}, \texttt{9cd755e1d768bbf228e7c9faf223b7459f7e0105}, accessed at: 2022-05-18},
  url = {http://github.com/curl/curl.git}
}

@misc{twin,
  title = {{tWin}},
  note = {\texttt{v0.8.1}, \texttt{689636ed829c1119ba5507bbd007d678d3d30904}, accessed at: 2022-05-18},
  url = {http://github.com/cosmos72/twin.git}
}

@misc{vim,
  title = {Vim},
  note = {\texttt{v8.2.1920}, \texttt{cf4d454df0619ee41ef40e7e91fce3fb061d7d5b}, accessed at: 2022-05-18},
  url = {http://github.com/vim/vim.git}
}

@misc{openssl,
  title = {{OpenSSL}},
  note = {\texttt{openssl-3.0.0-alpha7}, \texttt{f9a5682e5c0fbf8b17319d71b0040dba9f8b46ee}, accessed at: 2022-05-18},
  url = {http://github.com/openssl/openssl.git}
}

@misc{sqlite,
  title = {{SQLite}},
  note = {\texttt{version-3.33.0}, \texttt{ef215fbf3b581ef4e0273bb3932fa522af88fd7e}, accessed at: 2022-05-18},
  url = {http://github.com/sqlite/sqlite.git}
}

@misc{ffmpeg,
  title = {{FFmpeg}},
  note = {\texttt{n4.3.1}, \texttt{6b6b9e593dd4d3aaf75f48d40a13ef03bdef9fdb}, accessed at: 2022-05-18},
  url = {http://github.com/FFmpeg/FFmpeg.git}
}

@misc{postgres,
  title = {{PostgreSQL}},
  note = {\texttt{REL\_13\_0}, \texttt{29be9983a64c011eac0b9ee29895cce71e15ea77}, accessed at: 2022-05-18},
  url = {http://github.com/postgres/postgres.git}
}

@misc{libwebm,
  title = {{libWebM}},
  note = {\texttt{libwebm-1.0.0.27}, \texttt{82ac5fcdc8525820442faa90847b452113fc9394}, accessed at: 2022-05-18},
  url = {http://github.com/webmproject/libwebm.git}
}

@misc{xerces,
  title = {Xerces},
  note = {\texttt{v3.2.3}, \texttt{cf1912ac95d4147be08aef4e78f894a3919277d9}, accessed at: 2022-05-18},
  url = {http://github.com/apache/xerces-c.git}
}

@misc{bitcoin,
  title = {Bitcoin},
  note = {\texttt{v0.20.1}, \texttt{a62f0ed64f8bbbdfe6467ac5ce92ef5b5222d1bd}, accessed at: 2022-05-18},
  url = {http://github.com/bitcoin/bitcoin.git}
}

@misc{protobuf,
  title = {Protocol Buffers},
  note = {\texttt{v3.13.0}, \texttt{fde7cf7358ec7cd69e8db9be4f1fa6a5c431386a}, accessed at: 2022-05-18},
  url = {http://github.com/protocolbuffers/protobuf.git}
}

@misc{llvm,
  title = {{LLVM}},
  note = {\texttt{llvmorg-12.0.0}, \texttt{d28af7c654d8db0b68c175db5ce212d74fb5e9bc}, accessed at: 2022-05-18},
  url = {http://github.com/llvm/llvm-project.git}
}

@misc{qtbase,
  title = {{QtBase}},
  note = {\texttt{v6.2.0}, \texttt{cc60cf83db6bbf9775b1f7747a48d6b7eb24e585}, accessed at: 2022-05-18},
  url = {http://github.com/qt/qtbase.git}
}

@misc{mongo,
  title = {{MongoDB}},
  note = {\texttt{r4.4.6}, \texttt{72e66213c2c3eab37d9358d5e78ad7f5c1d0d0d7}, accessed at: 2022-05-18},
  url = {http://github.com/mongodb/mongo.git}
}

@misc{codechecker,
  title = {{CodeChecker}},
  note = {\texttt{v6.17.0}, \texttt{d0e2d7ba5f62d722e907d1ce8af6dbb24ee34e5d}, accessed at: 2022-05-18},
  url = {http://github.com/Ericsson/codechecker.git}
}

@misc{contour,
  title = {Contour},
  note = {\texttt{v0.2.0.173}, \texttt{574d721fb11c52db0d369a4119853282358c39cd}, accessed at: 2022-05-18},
  url = {http://github.com/contour-terminal/contour.git}
}

@inproceedings{typemig,
author={Wright, Hyrum K.},
booktitle={2020 IEEE International Conference on Software Maintenance and Evolution (ICSME)},
title={Incremental Type Migration Using Type Algebra},
year={2020},
volume={},
number={},
pages={756-765},
doi={10.1109/ICSME46990.2020.00085}
}

@inproceedings{autorefact,
title	= {Large-Scale Automated Refactoring Using ClangMR},
author	= {Hyrum Wright and Daniel Jasper and Manuel Klimek and Chandler Carruth and Zhanyong Wan},
year	= {2013},
booktitle	= {Proceedings of the 29th International Conference on Software Maintenance}
}

@manual{flags,
  title  = {Using Clang-Tidy},
  utl = {http://clang.llvm.org/extra/clang-tidy/#id2},
  author = {{LLVM Foundation}},
  note = {accessed at: 2022-05-18}
}

@manual{yamllib,
  title  = {LLVM YAML I/O Documentation},
  url = {http://llvm.org/docs/YamlIO.html},
  author = {{LLVM Foundation}},
  note = {accessed at: 2022-05-18}
}











@book{dahl1972structured,
	editor = {Dahl, O. J. and Dijkstra, E. W. and Hoare, C. A. R.},
	title = {Structured Programming},
	year = {1972},
	isbn = {0-12-200550-3},
	source = {Library of Congress Catalog Card Number: 72-84452},
	publisher = {Academic Press Ltd.},
	address = {London, UK, UK},
}

@book{cormen2009algorithms,
	author = {Cormen, Thomas H. and Leiserson, Charles E. and Rivest, Ronald L. and Stein, Clifford},
	title = {Introduction to Algorithms, Third Edition},
	year = {2009},
	isbn = {0262033844, 9780262033848},
	edition = {3rd},
	publisher = {The MIT Press},
}

@incollection{dijkstra1979goto,
	author = {Dijkstra, E.},
	chapter = {Go to Statement Considered Harmful},
	title = {Classics in Software Engineering},
	editor = {Yourdon, Edward Nash},
	year = {1979},
	isbn = {0-917072-14-6},
	pages = {27--33},
	numpages = {7},
	url = {http://dl.acm.org/citation.cfm?id=1241515.1241518},
	acmid = {1241518},
	publisher = {Yourdon Press},
	address = {Upper Saddle River, NJ, USA},
}

@article{krasner1988mvc,
	author = {Krasner, Glenn E. and Pope, Stephen T.},
	title = {A Cookbook for Using the Model-View-Controller User Interface Paradigm in Smalltalk-80},
	journal = {J. Object Oriented Program.},
	issue_date = {Aug./Sept. 1988},
	volume = {1},
	number = {3},
	month = aug,
	year = {1988},
	issn = {0896-8438},
	pages = {26--49},
	numpages = {24},
	url = {http://dl.acm.org/citation.cfm?id=50757.50759},
	acmid = {50759},
	publisher = {SIGS Publications},
	address = {Denville, NJ, USA},
}

@article{SZALAY2021111048,
title = {Practical heuristics to improve precision for erroneous function argument swapping detection in C and C++},
journal = {Journal of Systems and Software},
volume = {181},
pages = {111048},
year = {2021},
issn = {0164-1212},
doi = {http://doi.org/10.1016/j.jss.2021.111048},
url = {http://sciencedirect.com/science/article/pii/S016412122100145X},
author = {Richárd Szalay and Ábel Sinkovics and Zoltán Porkoláb},
keywords = {Static analysis, Function parameters, Argument selection defect, Type safety, Strong typing, Error-prone constructs},
abstract = {Argument selection defects, in which the programmer chooses the wrong argument to pass to a parameter from a potential set of arguments in a function call, is a widely investigated problem. The compiler can detect such misuse of arguments only through the argument and parameter type for statically typed programming languages. When adjacent parameters have the same type or can be converted between one another, a swapped or out of order call will not be diagnosed by compilers. Related research is usually confined to exact type equivalence, often ignoring potential implicit or explicit conversions. However, in current mainstream languages, like C++, built-in conversions between numerics and user-defined conversions may significantly increase the number of mistakes to go unnoticed. We investigated the situation for C and C++ languages where developers can define functions with multiple adjacent parameters that allow arguments to pass in the wrong order. When implicit conversions – such as parameter pairs of types – are taken into account, the number of mistake-prone functions markedly increases compared to only strict type equivalence. We analysed a sample of projects and categorised the offending parameter types. The empirical results should further encourage the language and library development community to emphasise the importance of strong typing and to restrict the proliferation of implicit conversions. However, the analysis produces a hard to consume amount of diagnostics for existing projects, and there are always cases that match the analysis rule but cannot be “fixed”. As such, further heuristics are needed to allow developers to refactor effectively based on the analysis results. We devised such heuristics, measured their expressive power, and found that several simple heuristics greatly help highlight the more problematic cases.}
}

@article{Horvath_Kovacs_Szecsi_2020,
  title={Report on the Differential Testing of Static Analyzers},
  url={http://cyber.bibl.u-szeged.hu/index.php/actcybern/article/view/4099},
  DOI={10.14232/actacyb.282831},
  abstractNote={&lt;p&gt;Program faults, best known as bugs, are practically unavoidable in today’s ever growing software systems. One increasingly popular way of eliminating them, besides tests, dynamic analysis, and fuzzing, is using static analysis based bug-finding tools. Such tools are capable of finding surprisingly sophisticated bugs automatically by inspecting the source code. Their analysis is usually both unsound and incomplete, but still very useful in practice, as they can find non-trivial problems in a reasonable time (e.g. within hours, for an industrial project) without human intervention.&lt;/p&gt; &lt;p&gt;Because the problems that static analyzers try to solve are hard, usually intractable, they use various approximations that need to be fine-tuned in order to grant a good user experience (i.e. as many interesting bugs with as few distracting false alarms as possible). For each newly introduced heuristic, this normally happens by performing differential testing of the analyzer on a lot of widely used open source software projects that are known to use related language constructs extensively. In practice, this process is ad hoc, error-prone, poorly reproducible and its results are hard to share.&lt;/p&gt; &lt;p&gt;We present a set of tools that aim to support the work of static analyzer developers by making differential testing easier. Our framework includes tools for automatic test suite selection, automated differential experiments, coverage information of increased granularity, statistics collection, metric calculations, and visualizations, all resulting in a convenient, shareable HTML report.&lt;/p&#38;gt;}, journal={Acta Cybernetica},
  author={Horváth, Gábor and Kovács, Réka Nikolett and Szécsi, Peter},
  year={2020},
  month={Oct.} }
