\chapter{Introduction}
\label{ch:intro}

\section{Motivation}

Static analysis is a method to analyse the source code of software projects without performing a real execution of the application.
It is widely used in industry to find bugs and code smells during development, to aid in the prevention of bad code that misbehaves in
production.
Among various methods, the most important techniques are the ones that are based on pattern matching on a syntactic representation of
the software project.
Unfortunately, for programming languages in the C family, such as C++, the concept of "separate translation" causes issues for static
analysis.
\par As most static analysers are built upon compilers, and in C++, each compiler only sees the local information in the source file
(also known as the Translation Unit) it is to compile or analyse (as opposed to a more project-level knowledge), crucial details
might be hidden, which lowers the accuracy of the analysis. Clang-Tidy is a static analysis rule collection that is built upon
the LLVM Compiler Infrastructure's C-family compiler, Clang.
It performs pattern matching on Clang's "Abstract Syntax Tree" (AST) representation, and generating diagnostics based on which analysis
modules -- called "checks" -- the user turns on. We will address both the LLVM library and AST matchers in later chapters of the thesis.
\par Let us imagine a checker, that keeps a statistics on how many times a return value of a non-void function is used (in the remainder
of the thesis I will refer to the usage of the value as being checked). This property is important, because there exist a great amount of
functions, whose return value should be checked in most situations but remain unchecked in quite a lot.
\paragraph{Some examples:}
\begin{itemize}
	\item POSIX read: returns the number of files read; this return value can also indicate errors with it being -1.
	\item POSIX scanf: returns the number of items in the argument list successfully filled; also indicates errors with EOF return.
	\item (cstdio) std::remove: return indicates success or error.
	\item (algorithm) std::remove: Does not remove. It returns an iterator, and we still need to use erase for all elements after this iterator.
	\item \texttt{std::remove\_if}: Same as remove.
	\item container specific erase: Returns an iterator to the next element after the removed. 
	\item container specific insert: Returns an iterator to the first of the new elements inserted.
\end{itemize}
It is important to note, that the nodiscard attribute was introduced for this exact reason, for functions to give warning if their
return value is unchecked.
A function can obviously exist outside of the translation unit of its declaration. If such analysis with our imagined checker is done
separately on each translation unit, it is easy to see how that can affect the outcome. A function might be called 100 times and 
checked 95 times through. We would want to give warnings for the unchecked 5\% of those calls, but if, for example, these are in a 
separate translation unit, then the analysis would return with 0 checks out of 5 calls. We would not want to give warnings to a
function that is unchecked in all 100\% of its calls. The detail of the statistics, that it was only unchecked in 5\% is lost,
unless we use project level knowledge during our analysis. Consider this code example:
\begin{lstlisting}[language={C++}]
	// First translation unit
std::vector<int> vector = {7, 9, 10};

vector.insert(vector.begin(), 6);
vector.insert(vector.begin(), 5);
vector.insert(vector.begin(), 2);
vector.insert(vector.begin(), 1);

// Second translation unit

auto it = vector.insert(vector.begin() + 2, 4);
vector.insert(it, 3);
\end{lstlisting}
With separate analysis, we would get 0\% checked in the first TU and 50\% in the second one. With project level knowledge, however we
would get 12.5\%. We used insert without a care towards its return value, since we did not intend to use it for future insertions,
except for one occasion.  

\par Unfortunately, the current versions of Clang-Tidy checks only access what is visible to the compiler, which is a local information.
Several classes of security issues and bad coding patterns might be diagnosed if the implemented checks would be capable of creating 
percompilation knowledge, and reusing the full knowledge about the project during diagnosis.
The work of the thesis is to enhance Clang-Tidy on the infrastructure level to support multi-pass analyses in a generic manner, by 
utilizing the ideas similar to that of MapReduce.
\par This is achieved by allowing individual checks to store check-specific data on a thread-safe location.
A subsequent execution of the analysis will be able to do the pattern matching fine-tuned with the data stored in the previous step also
available.
To prove the usability of the solution, a new safety and security related check, currently not provided by Clang-Tidy, will be developed
utilizing the new infrastructure created in this work.
In the end, the results of the thesis will allow the international community behind LLVM to develop and make available a wider potential of
checks.
